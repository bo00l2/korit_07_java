금일 수업
1. 상속 관련 예제 복습
2. 추상 클래스 / 추상 메서드
3. 인터페이스
4. casting

# intellij에서의 .md 파일에서의 자동 줄바꿈 설정
1. ctrl + alt + s 누른다 / command + , 누른다 설정
2. 설정 에디터 / Editor -> 일반

# 추상 클래스(Abstract Class)
- abstract - 추상적인
## 추상 클래스의 정의
1. 추상 메서드가 하나라도 포함되면 해당 클래스는 추상 클래스로 정의돼야 함.
2. 추상 클래스는 객체를 생성할 수 없음 -> 일반 클래스와의 차이
3. 그 외의 다른 특징은 일반 클래스와 동일함
4. 상속을 전제로 하는 클래스

- 추상 메서드(abstract method) - 선언만 있고, 구현은 없는 메서드
- 추상 크래스(abstract class) - 추상 메서드가 '하나 이상인' 클래스

- 일반 메서드 vs 추상 메서드 구조 차이({} 영역의 유무)
```java
// 일반 메서드
public void showInfo(){
    System.out.println("제 이름은 " + name + "입니다.");
}
// 추상 메서드
public abstract showName();
```

## 추상 클래스의 장점
코드의 재사용성을 높이고 설계를 보다 명확하게 할 수 있도록 도와준다.

## 추상 클래스의 목적
1. 공통된 기능 제공 : 여러 클래스에서 공통적으로 사용하는 기능을 추상 클래스에서 정의 가능
2. 구체적인 구현 _강제_ : 추상 메서드를 통해 자식 클래스가 '반드시 특정 메서드를' 구현하도록 강제할 수 있음.
3. 코드의 재사용성 : 중복되는 코드를 줄이고, 유지보수성을 향상.

## 주의사항
객체 생성을 못함
```java
// 추상 클래스는 객체 생성은 '원래는' 못한다.
        Factory factory1 = new Factory() {
            @Override
            public void produce(String model) {
                System.out.println(this.getName() + "에서 [ " + model + " ]을 생산합니다.");
            }

            @Override
            public void manage() {
                System.out.println("가전 제품 공장을 관리합니다.");
            }
        }; 
// ;를 꼭 명시해야하는데 이 전체 코드라인이 메서드를 정의하는 것이 아니라 객체를 생성한 것이기 때문
```
abstract 접근 지정자와 리턴 타입 사이에 명시되면
클래스에도 동일하게 abstract 키워드가 적용돼야 한다.
왜냐?
-> 추상 메서드가 하나라도 있으면 추상 클래스로 정의되어야만 하니까.

# 인터페이스(Interface)
- Java에서 클래스가 구현해야하는 '메서드들'의 집합을 정의하는 일종의 규약(protocol)
- 인터페이스는 메서드의 시그니처(메서드명, 리턴 타입, 매개변수 목록)만을 포함하며, 메서드의 실제 구현은 포함하지 않음 -> 추상 메서드만 있음
- 다중 상속을 지원 -> 이를 통해 클래스가 여러 인터페이스를 구현할 수 있음.
  - 추상 클래스는 단일 상속을 지원해서 상속 과정을 알아보기 쉽다고 작성했는데,
  - 얘는 다중 상속을 지원하기 때문에 또 편하다고 이야기한다.
## 특징
1. 추상 메서드 : 인터페이스 내의 모든 메서드들은 기본적으로 추상 메서드
   - 추상 클래스는 일반 메서드도 있었지만, 인터페이스는 강제적으로 추상 메서드
2. 상수 : 인터페이스 내에 선언된 변수는 모두 자동으로 'public static final' 상수로 취급됨
3. 다중 상속 : 클래스는 여러 인터페이스를 구현(implements)할 수 있음.

interface 패키지 코드 / 주석 읽으면서 복습하기
    - 어떤 기능을 interface로 할지, 클래스로 할지 고민해서 코드 작성
```java
/*
        interface 이기 때문에 변수 앞에 접근 지정자를 명시하지 않고,
        final 키워드도 적지 않지만

        public final이 생략되어있다. 그래서 String 앞에 final을
        명시하더라도 Intellij 상에서 불필요하다는 안내가 나온다.
        복습할 때, String 앞에 한 번 final 붙여보기

        안되는 예시 나열!
     */
public interface Press{
    String age; // final(인스턴스 변수) 선언 불가능
    public Press(){}; // 생성자 불가능
    void popOut(){
        System.out.println("추상 메서드 x / 얘는 일반 메서드");
    }
}
```

아래 코드라인은 클래스의 객체로 필드를 선언한다.
```java
public class TvController{
    // 필드 선언
    private PowerButton powerButton;    // 접근지정자 클래스명 객체명 -> 여태까지의 작성방법과 다르다.
    private ChannelDownButton channelDownButton;

    public TvRemoteController(PowerButton powerButton,
                              ChannelDownButton channelDownButton  ) {
        this.powerButton = powerButton;
        this.channelDownButton = channelDownButton;
    }
}
// 위의 클래스에서 선언한 생성한 필드들을 Main에서 객체를 생성하는 방법
public class Main{
    public static void main(String[] args) {
        TvRemoteController tvRemoteController = new TvRemoteController( // 객체 생성
                new PowerButton(), new ChannelDownButton()
                // tvRemoteController 라는 객체 안에 버튼 3개의 이름 없는 객체를 new로 생성
        );
    }
}
```

## 추상 클래스와의 공통점
- 모두 추상 메서드를 포함할 수 있고, 이를 서브 클래스에서 구현해야만 함.
## 추상 클래스와의 차이점
- 추상 클래스
  1. 부분 구현 허용 : 추상 클래스는 추상 메서드 뿐만 아니라 일반 메서드도 포함할 수 있다.
  2. 상태 저장 가능 : 추상 클래스는 field를 가질 수 있다.
  3. 단일 상속 : (일반) 클래스는 하나의 추상 클래스만 상속받을 수 있다.
  4. 생성자 : 추상 클래스는 생성자를 가질 수 있다.
```java
// 어떤 추상 클래스
public abstract class Person{
    // 필드 선언
    private String name;    
    // AllArgsConstructor
    public Person(String name){
        this.name = name;
    }    
    // method 구현
    public abstract introduce();
}
// 위의 추상 클래스를 상속받는 Person
public class Student extends Person {
    // 서브 클래스의 필드 선언
    private String school;
    // 추상 클래스가 AllArgsConstructor 생성자만 가지고 있기 때문에
    // Student 클래스가 객체를 생성할 수 있는 경우의 수는 이렇게 두 가지만 존재하게 된다.
    public Student(String name){
        super(name);
    }    
    public Student(String name, String school){
        super(name);
        this.school = school;
    }
}
```
이상의 코드라인으로 알 수 있는 것은, 객체 생성을 직접적으로 하지 못하는 추상 클래스의 생성자의 유무로 인해 자식 클래스의 생성자 정의 방식(객체 생성 방식)을 통제할 수 있다는 점이다.

그래서 특정 서브 클래스의 객체 생성 방식을 강제하고 싶을 때 사용하는 것이 추상 클래스의 생성자라고 생각하면 된다.

  5. 다양한 접근 지정자(Access Modifier) : 추상 클래스의 메서드와 변수는 다양한 접근 지정자를 가질 수 있다.
- 인터페이스
    1. 완전한 추상화 : 인터페이스는 기본적으로 모든 메서드가 추상 메서드(Java8 이후에 default / static 메서드를 사용가능하긴 하다.)
    2. 인터페이스는 인스턴스 변수(필드 중 객체마다 값이 다른 변수를 의미함)를 가질 수 없고, 상수만 선언 가능(final 키워드)
    3. 다중 상속 : 클래스는 여러 인터페이스를 '구현할 수 있다.'(상속과 용어를 구분짓는 편)
    4. 생성자 없음 : 인터페이스는 생성자를 가질 수 없다.
          - 일단 필드에서 객체마다 다른 값을 지닐 수 없고 상수 선언 가능하기 때문에 필드에 값을
              대입하는 생성자 자체를 만들 수 없다.
    5. 자동 public : 인터페이스의 메서드들은 자동으로 public이며, 메서드 선언에 접근 지정자를 명시할 필요 x(근데 또 Java8 이후에 default / static 메서드가 생긴 점이 문제긴 하다.) 다른 곳에서 쓸 것을 전제로 만들어짐