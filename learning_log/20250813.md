# 금일 수업 계획
Generic
Collections

## JS에서의 객체 정의 방식
```jsx
const person = {
    name = "김일"
    age = 20;
};
```
이상의 형태가 python에서는 dictionary라는 표현을 쓰고, java에서는 또 map이라고 쓴다.
person1.name = "김이";


# 제네릭(Generic)
## 개념 및 정의
클래스나 메서드가 다룰 데이터 타입을 미리 명시하여 재사용성과 유연성을 높이는 기술

### 타입 매개변수(Type Parameter)
- 클래스나 메서드에서 사용할 실제 타입을 '대신하여 사용하는 매개변수'
- 일반적으로 알파벳 대문자 하나로 표기함.
    1. T(Type) : 일반적으로 클래스 타입을 나타낼 때 사용
  2. E(Element) : 컬렉션(추후 수업)의 요소를 나타낼 때 사용
  3. K(Key) : Map(추후 수업)의 Key를 나타낼 때 사용
  4. V(Value) : Map의 Value 또는 제네릭 타입의 리턴 값으로 사용
### 재사용성
- 제네릭을 사용하면 다양한 자료형에 대해 하나의 클래스나 메서드를 정의할 수 있어 코드의 재사용성을 높이고 중복을 줄인다.

    - 예를 들어 method overloading 개념이 있을 경우, Person 객체를 참조하여 bmi를 계산한다고 가정하자
```java
package org.example;

import lombok.*;

@Builder
@Data
public class Person {
    private String name;
    private double height;
    private double weight;
}

public void calcBmi(Person person) {
    // Person class의 각 field들에 private을 적용했기 때문에 값을 불러오기 위해서는
    // Getter 를 사용해야만 한다. 하지만 너무 코드가 길어지기 때문에
    String name = person.getName();              // 지역 변수들을
    double height = person.getHeight()*0.01;     // 선언하고 거기에 값을 대입하여 사용
    double weight = person.getWeight();
    double bmi = weight/(height*height);         // 그러면 여기서부터 위의 코드 복사 가능
    System.out.println(bmi);
    String result = "";
    if (bmi < 18.5) {
        result = "저체중";
    } else if (bmi < 23){
        result = "정상";
    } else if (bmi < 25) {
        result = "비만 전 단계";
    } else if (bmi < 30) {
        result = "1단계 비만";
    } else if (bmi < 35) {
        result = "2단계 비만";
    } else {
        result = "3단계 비만";
    }
    System.out.println(name + "님의 BMI 지수는 " + bmi + " 으로 " + result + "입니다.");
}
```
이상과 같이 쓸 수 있겠다. 그렇다면, 만약에 Student 클래스가 Person 클래스를 상속받았다고 가정할 때,
Student 클래스용으로 또 method overloading을 해야하는가와 같은 문제가 있다.
그리고 Student의 상속을 받는 MiddleSchoolStudent라든지 HighSchoolStudent가 있으면 더 골치 아파지겠다.
* 참고 : 사실은 upcasting이 이루어지기 때문에 별 문제는 없다.

### 타입 안정성(Type Safety)
- 컴파일 시점에 타입 체크를 할 수 있어 프로그램의 안정성을 높이고, 명시적인 형변환을 줄임.

# Java 제네릭 와일드카드(Generic Wildcard)

## 제네릭
- 클래스, 인터페이스, 메서드에 사용되는 자료형을 매개변수화 할 수 있도록 하는 문법으로 다양한 타입에 재사용이 가능

```java
public class Box<T>{
    // 필드 선언
    private T value;
    public void setValue(T value){  //
        this.value = value;
    }
    public T getValue(){
        return value;   //
    }
}
```
과 같은 방식으로 작성했을 때 value의 자료형을 고정시키지 않고 사용이 가능함.
value에 String / Integer / Double / Product / Item ... etc 등으로 사용 가능하다.
즉, Java 자체의 자료형(class) 뿐만 아니라 개발자가 정의한 것도 집어넣을 수 있다는 점에서 
재사용이 높다고 할 수 있다.

## 와일드카드
- 아싱의 제네릭 타입을 사용할 때 구체적인 타입을 명시하지 않고 범용적으로 처리하고 싶을 때 사용함.
`?` 기호를 사용한다.

```java
import java.util.ArrayList;

public static void main(String[] args) {
    List<?> exampleList = new ArrayList<String>();
}
```
`<?>`은 어떤 타입이든 가능하다는 의미이다.

### 종류
1. 모든 타입 허용
    - 읽기 전용. 어떤 타입이든지 받아야만 할 때
2. T 또는 T 서브 타입(자식 클래스)
    - 읽기 전용. 제한된 타입에서 읽을 때
3. T 또는 T의 슈퍼 타입(부모 클래스)
    - 쓰기 전용. 제한된 타입으로 넣을 때

# Collection
- 여러 객체를 모아놓은 것들을 의미함 -> 배열과는 좀 차이가 있다.
- 다만 Java에서의 List는 Python에서의 List와도 차이가 있다.

## 종류
1. List : 순서가 있는 데이터의 집합으로, 중복된 요소를 허락함.
    - ArrayList : 배열 기반의 리스트, 요소(element) 접근 속도가 빠름.
    - LinkedList : 연결 리스트, 삽입 / 삭제 속도가 빠름.
2. Set : 중복을 허용하지 않는 데이터들의 집합(중1 때 배우는 그 집합임)
    - HashSet : 해시 테이블 기반의 집합, element의 순서를 보장하지 않음.(List와의 차이 # 2)
    - TreeSet : 이진(binary) 검색 트리 기반의 집합, 요소가 정렬된 상태로 유지됨.
3. Map : key / Value의 쌍으로 이루어진 데이터들의 집합.
    - HashMap : 해시 테이블 기반의 맵, 키의 순서를 보장 x
    - TreeMap : 이진 검색 트리 기반의 맵, 키가 정렬된 상태로 유지

* Java 상에서의 Map의 키(Key)-값(Value) 쌍을 지칭하는 용어 : Entry
    - key 하나당 value는 하나 (즉, 키가 같다면 value는 가장 최근 걸로 덮어쓰기가 된다.)
* Js 상에서 객체의 키-값 쌍을 지칭하는 용어 : Property(속성)
* 근데 문제는 Python에서의 한국어로 속성을 지칭하는 영문 용어 : Attributes - Java 상에서의 field

### 차이점
1.  List와 Array의 차이점
선언 방식
```java
public static void main(String[] args) {
    List<String> strList = new ArrayList<>();
    String[] strArray = new String[5];
}
```
List의 경우 인덱스 넘버 고정 x
배열의 경우 인덱스 넘버 고정 o

2. 값을 대입하는 방법
```java
public static void main(String[] args) {
    String[] strArray = new String[5];

    // Array -> 원하는 인덱스에 원하는 값 직접 대입
    strArray[0] = "김영";
    strArray[4] = "김사";

    // List -> 메서드를 통해 원하는 데이터를 추가한다.
    strList.add("java");
}
```
3. 출력 방식
```java
public static void main(String[] args) {
    // Array
    System.out.println(strArray);
    System.out.println(Arrays.toString(strArray)); // 정적 메서드 사용
    // List                     - toString()의 오버라이딩
    System.out.println(strList);
}
```

### List 특징
element(List 내의) 검색 -> contains() 메서드 사용
ㄴ 리스트명.contains(목적어)

특정 element의 삭제 
-> 리스트명.remove(특정 element)

전체 element 출력 방법
```java
public static void main(String[] args) {
    for (int i=0; i<strList.size(); i++){   // .size() 리스트의 크기 메서드
        System.out.println(strList.get(i) + " "); 
        // .get(인덱스넘버) 추가된 element를 조회하는 메서드 
    }
    System.out.println();
    // 향상된 for문
    for (String elem : strList){
        System.out.println(elem + " ");
    }
}
```

List는 순서가 있고 중복을 허용하는 반면,
Set의 경우 순서가 없고 중복은 허용하지 않기 때문에
List -> Set / 혹은 Set -> _List로의 형변환이 중요하다._
예를 들어 List로 전체 설문을 받고, Set을 통해 중복을 제거하여
후보군만 남기는 등의 형태로 많이 사용된다.
또한 Set으로 중복을 제거한 후에 다시 List로 돌려서 .get(인덱스넘버)로
조회도 할 수 있다.
Set은 순서가 없어서...

그래서 Set은 우리가 중1 때 배우는 집합 개념과 유사하다.
다만 집합은 숫자로만 이루어졌던 반면에
Set은 다양한 자료형을 기준으로 만들어질 수 있다는 차이가 있다.

List의 element를 Set에 대입 -> 세트명.addAll(리스트명);
```java
strSet.addAll(strList);
strList.addAll(strSet); // 반대로도 가능
// 리스트값을 Set에 대입해도 리스트 요소들은 그대로 저장되어있다.
```

### Map
* Map에서 사용하는 메서드
- Map에 key - value 쌍(entry) 삽입 메서드 -> .put(키, 값);
- Map에서 키-값을 조회 메서드 -> .get("키값"); // 키-값 전체 출력
- Map에서의 값(value)만 출력하는 방법
-> 맵네임.get(key) // value만 출력함.
- Map의 키(key) 검색 방법 -> .keySet();
* .valueSet(); 은 없음
-> 이유는 Key는 어차피 중복을 허용하지 않기 때문에 Set으로 바꾸는 게 가능한 반면,
  복수의 Key에서 동일한 value가 존재할 수 있기 때문에 직접적으로 Set으로 바꾸지 않습니다.

* 특정 key의 value 수정
    1. key에는 value가 하나 밖에 없기 때문에 최근걸로 덮어쓰기 된다.
    2. .replace(); 로 값을 수정할 수 있다.

- 두 가지 방법이 있는 이유는 .put()의 경우에는
  없는 key라면 key를 새로 생성해서 value를 초기화하겠지만
  있는 key라면 value에 재대입을 하게 됩니다.

  반면 .replace()는 없는 key라면 value 값의 갱신이 일어나지 않습니다.
  있는 key라면 재대입이 일어난다는 차이가 있습니다.(Set의 개념 정확히 이해)

* 특정 key의 존재 여부 -> containsKey(); -> boolean
* 특정 value의 존재 여부 -> containsValue(); -> boolean

- Map의 엔트리로부터 Set 생성
```java
public static void main(String[] args) {
    // Map의 엔트리로부터 Set을 생성
    Set<Map.Entry<String, String>> entrySet1 = new HashSet<>();
    // 이상의 코드는 Set을 하나 만드는데, 내부에 Key가 String, Value가 String인 Map이 통째로
    // 들어간다는 것을 의미합니다.
    Set<Map.Entry<String, String>> entrySet2 = strMap1.entrySet();
    //이상의 코드는 strMap1의 Key-Value 쌍을 Set로 바꾸는 메서드인 .entrySet()의 호출 결과를
    // entrySet2 라는 변수에 담았음을 뜻합니다.
    System.out.println(strMap1);    // 출력 결과 - 중괄호
    System.out.println(entrySet2);  // 출력 결과 - 대괄호
}
```