# 참조 자료형 캐스팅(Reference Type Casting)
- 객체 지향  프로그래밍(OOP)에서 중요한 요소 중 하나
## 사전 지식
- Java 상에서의 자료형은 크게 두 가지로 구분됨.
    1. 기본 자료형(Primitive Type) : int, double, char, float, long
    2. 참조 자료형(Reference Type) : 객체를 참조하는 변수로, 클래스나 인터페이스로 생성된 객체
- 참조 자료형 캐스팅이란? - 객체의 자료형을 변환하는 작업.
- int -> double / int -> long 으로 변경하는 것은 형변환(conversion)이라고 한다.
## 캐스팅 종류
1. Upcasting : 하위 클래스 타입의 객체를 상위 클래스 타입으로 변환
2. Downcasting : 상위 클래스 타입의 객체를 하위 클래스 타입으로 변환

## 미리 기억해둬야 할 연산자(Operator) : instanceof
 - 어떤 객체가 특정 생성자(constructor)의 인스턴스인지를 확인하는 연산자
   - 타입 체크를 하기 위해
   - 상속 관계를 확인하기 위해
   - 함수나 메서드 내에서 매개변수의 인스턴스 종류에 따라 분기할 때 유용
ex : 1 + 1 = 2 에서 +가 연산자 / = 대입 연산자인 것처럼,
ex : 객체명 instanceof 클래스명 -> return true / false (조건문에서 주로 사용)

## 참조 자료형의 배열 생성
```java
public static void main(String[] args) {
  // 각 클래스의 객체 생성
  Computer computer1 = new Computer();
  AirConditioner airConditioner1 = new AirConditioner();
  Speaker speaker1= new Speaker();

  // 참조 자료형의 배열을 생성(비어있는거) 예시
  Power[] powers = new Power[5];    // # 1 인덱스 개수를 직접 명시
  Power[] powers = {new Computer(), new AirConditioner(), new Speaker()};   // # 2 클래스 객체를 선언하는 방법

  // centralControl 객체를 만들면서 내부의 필드에 비어있는 Power[] 배열을 집어넣음
  CentralControl centralControl = new CentralControl(
          new Power[5] // 주석에 있는 powers 도 가능
  );
  centralControl.addDevice(computer1);    // 여기서 (암시적) 업캐스팅이 Power로 이루어졌다.
}
```
Power 배열의 마지막 인덱스인 4를 넘어가게 되면 대입이 이루어지지 않는다.


### Upcasting
- 암시적으로 (Implicit)으로 이루어짐
  - 알아서 바뀐다. 근데 언제 알아서 바뀌었는지는 개발자가 알고 있어야 함.
```java
Dog dog1 = new Dog();   // dog1 객체 생성
Animal animal1 = dog1;  // dog1 업캐스팅 (업캐스팅은 명시적으로 해주지 않아도 가능함)
```
### Downcasting
- 명시적(Explicit)으로 이루어짐
- 방법
  : (클래스명)객체명; -> (int)2.3; 과 같은 방식. conversion의 객체 버전이라고 생각하면 된다.
  그래서 기본 자료형의 형변환에서 벗어나서 참조 자료형까지 고려해야 한다.
  - 반드시 개발자가 적절한 장소와 시간대에 사용해야 한다

```java
Dog dog2 = (Dog) animal2;   // 부모 클래스인 animal2가 하위 클래스인 Dog를 다운캐스팅 받았다.
```

## 업캐스팅과 다운캐스팅의 활용
- 캐스팅은 다형성(Polymorphism)을 구현할 때 사용. 상위 클래스 타입으로 객체를
처리하면서도 특정 상황에서는 하위 클래스의 고유 기능을 사용 가능
## 장단점
- 장점 :
  - 코드 유연성 : 업캐스팅을 통해 '다양한 객체를 하나의 상위 클래스 타입으로 관리' 가능
  - 다형성 구현 : 메서드 오버라이딩과 함께 사용하면 코드의 재사용성 ↑
- 단점 :
  - 다운캐스팅의 위험성 : 잘못 다운캐스팅을 하게 될 수 있음.
    - 상위 클래스 A와 하위 클래스 B, C가 있다고 가정할 때, B의 객체인 b를 A로 업캐스팅한 후에 C로 다운 캐스팅을 하려고 시도하면 컴파일링 오류 발생.
  - 복잡성 증가 : 코드 가독성이 떨어질 수 있음.
    - 이렇게 바꿨다가 저렇게 바꿨다가 하기 때문인데 특히 업캐스팅의 경우 암시적으로 일어나기 때문에 어디서 이루어졌는지 확인 못하고 있다가 갑자기 명시적으로 작성하는 다운캐스팅이 튀어나와서 초심자들이 코드 읽는게 어려워지는 경우가 발생할 수 있다.
  - 이상의 문제들을 해결하기 위한 연산자가 -> instanceof 이다.
    코드 예시
```java
public static void main(String[] args) {
    System.out.println(objectA instanceof ClassA); // 결과값 true / false
}
// objectA : 검사하려는 객체명
// ClassA : 객체가 검사될 클래스 / 인터페이스
```
- return 값은 objectA가 ClassA의 인스턴스이거나 '하위' 클래스의 인스턴스인 경우 true 아니면 false

- 클래스A 객체명 = new 클래스B();를 통해 객체를 생성했을 경우
1. Override가 적용된 메서드, 즉 자식 클래스의 메서드가 호출됨.
2. 클래스B(자식 클래스)의 고유 메서드는 호출 불가능.

 그럼 어차피 재정의된 method 버전으로 호출이 될거라면 애초에
클래스B 객체명 = new 클래스B();로 생성해버리면 재정의된 method도 호출되고 고유 method도
호출할 수 있으니까 골치 아픈 거 아니냐고 생각할 수 있다.

            즉, B b new B();로 애초에 객체를 생성하면 되지 않냐는 아까까지의 의문은
             A의 자식 클래스가 B 하나뿐일때만 적용된다고 볼 수 있다.
             A의 자식 클래스 B C D F ... 여러 개가 있다고 가정한다면
             그것을 업캐스팅 했을 때 A가 가지고 잇는 부모메서드를 호출함으로써
             !! 다수의 서로 다른 클래스의 객체들을 통제할 수 있다는 장점 때문에
             업캐스팅을 적용하게 된다.!!
             그리고 다운 캐스팅을 해서 각각 클래스의 고유 메서드도 실행시킬 수 있겠다.


- 다운캐스팅은 '명시적'으로 이루어져야 한다.

## .getClass() / .getSimpleName()
- .getClass() -> 클래스명을 return하는 method + 패키지 경로 포함
- .getClass().getSimpleName() -> 클래스명만 출력됨.
현재 보시면 method의 결과값을 가지고 다시 . 찍어서 그 다음 method를 호출했습니다.
이상의 개념을 chaining method라고 해서 return값의 유형을 명확하게 알고 있어야
그 다음 어떤 method를 실행시킬 것인지를 알 수 있습니다.

