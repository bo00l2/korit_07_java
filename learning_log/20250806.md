# cord convention 관련

```java
import java.util.Scanner;

public class PersonMain {
    public static void main(String[] args) {
        // 사용할 외부 및 내부 클래스 목록들 전부 import 해옴
        Scanner scanner = new Scanner(System.in);
        Array08 array08 = new Array08();
        // 사용하는 변수 목록들 전부 선언
        int randomNum;
        double[] scores = new double[25];
        String[] students = new String[25];
        // ...
        // 막 내부 로직들 엄청나게 써놓고 있다고 가정하다가
        // 저 밑에서 갑자기
        // students가 튀어나왔다고 가정해보자
        if (randomNum < 0)
        {
            // 이런 방식으롤 실행문을 써야 한다. 라는 식으로 회사에서 정하는 경우가 있음
        }
    }
}
```
### 배열의 출력
엄밀히 말하자면 저희는 배열을 출력한게 아니라 여태까지 배열 내부의 element들을 출력해왔다.
System.out.println(arr01); 과 같은 출력문을 작성했을 때
주소값만 나온다는 사실을 확인할 수 있었다.

    근데 element의 값을 조정하거나, 더하거나와 같은 추가적인 가공을 하기 위해서 for 반복문을
    사용해왔는데, 굳이 변형이 없고 배열 자체를 확인하고 싶을 때마다
    main에 반복문 작성하든지 method를 정의하든지 하는 일은 번거로운 일이 된다.

    Arrays 클래스를 사용하고, '정적' 메서드인 .toString(배열명)을 사용하면
    배열 전체를 출력할 수 있다.

    여기서 우리는 클래스명.메서드명()이라는 점에 주목할 필요가 있다.
    scanner.nextLint()과는 다름
    그리고 toString()이라는 메서드도 곧 사용하게 된다.

    여기서 중요한 점은 동일한 method 명이라고 하더라도 어떤 클래스에 종속되어있는가에 따라
    다른 결과값을 지닐 수 있다는 점이다.

```java
public class ArrayString{
    public static void main(String[] args) {
        int[] numbers = { 1,2,3,4,5,6,7,8,9,10};
        System.out.println(Arrays.toString(numbers));

        Arrays.sort(nums); // 오름차순 정렬
        Arrays.sort(nums, Comparator.reverseOrder()); // 내림차순 정렬
    }
}
```
- 이상의 경우는 보면 sort() 메서드에 오름차순에서는 argument가 하나였는데,
내림차순할 때는 보니까 argument가 두 개이다.
이상의 과정이 overloading이 이루어졌다는 점을 파악하자.
- 두 번째 argument로 Comparator.reverseOrder();가 사용되었는데,
Comparator.reverseOrder()의 결과값 / return 값이 sort() 메서드의
두 번째 argument로 사용되었다는 점에서 역시 함수형 프로그래밍의 일종이라고
볼 수 있다.
- 근데 Comparator.reverseOrder() 메서드를 쓰려면
  기본 자료형(원시 자료형 / primitive type) int[] 배열을 사용할 수 없어서
  Integer[] 배열을 사용하였는데
- 현재는 char -> String 처럼 int -> Integer 라고만 생각해두면 된다.

## 이중 배열
다차원 배열(Muti-Dimensional Array) 중에서 2차원 배열

: 다차원 배열은 2차원 이상의 배열을 의미하지만, 개발 환경 상
2차원 배열 이상을 다루는 경우는 극히 드물기 때문에 2차원 배열을
기준으로 강의함

    형식 :

    int[][] arr01 = new int[크기][크기];        - 선언 방식 # 1
    int[][] arr02 = new int[크기][];           - 선언 방식 # 2
    int[][] arr03 = { {1, 2}, {3, 4} , {5, 6}} - 선언 방식 # 3 및 초기화

    2차원 배열 선언 시, 열의 크기는 지정하지 않아도 되지만, 행의 크기는 항상 지정해야 함.
        -> 2 번 방식에 해당한다.
         1열 2열 (column)
          ↆ  ↆ
        { 1, 2 },   →   1 행(row)         가로줄을 '행'
        { 3, 4 },   →   2 행
        { 5, 6 }    →   3 행

```java
public class Array13 {
    public static void main(String[] args) {
        int[][] arr03 = { {1, 2}, {3, 4} , {5, 6}};
        // 5라는 숫자를 뽑아내고 싶다
        System.out.println(arr03[2][0]);    // 결과값 : 5
        System.out.println(arr03[2]);       // 결과값 : [I@36baf30c
        System.out.println(arr03);          // 결과값 : [[I@7a81197d
        System.out.println(Arrays.toString(arr03)); // 결과값 : [[I@5ca881b5, [I@24d46ca6, [I@36baf30c]

        // 2차 배열의 element 추출 -> 중첩 for문을 사용
        for(int i=0; i<arr03.length; i++){
            // 근데 반복문 하나 파고 들어가봐도 여전히 배열이기 때문에 이 부분에 서 1차 배열을 추출하기 위한
            // 반복문을 추가로 작성해야 한다.
            for(int j=0; j<arr03[i].length; j++){   // arr03[i].length 주목해야함
                System.out.print(arr03[i][j]);      // 결과값 : 123456
            }
        }
    }
}
```

# 상속(Inheritance)
- 객체지향프로그래밍(OOP)의 핵심 개념 중 하나로, 기존 클래스(부모(슈머) 클래스)의
field와 method를 재사용하여 새로운 클래스(자식(서브) 클래스)를 만드는 것을 의미함.

## 상속의 필요성
- 상속을 통해 공통적인 기능을 부모 클래스에 정의하고, 이를 '여러' 자식 클래스가
재사용 가능

    - 동물(Animal) 클래스가 있고, 이를 상속받는 개(Dog) / 고양이(Cat) 클래스가 있다고
      가정했을 때, 동물의 공통적인 field(이름 / 나이 등)와 행위(걷기 / 먹기 등)을
      부모 클래스에 정의, 개와 고양이는 각각 고유한 특성(짖기 / 우다다다)을 추가할 수 있음

- 이상의 과정을 거쳤을 때 얻을 수 있는 이점 : Dog에 이름 / 나이 / 걷기 / 먹기 / 짖기를 정의하고,
  또 Cat에다가 이름 / 나이 / 걷기 / 먹기 / 우다다다를 정의하는 등의 공통된 부분을

  정의하는 일 없이 특정 field 및 메서드만 정의하면 됨. -> 중복된 코드를 줄일 수 있다.

## 상속의 특징
1. 단일 상속
   - Java는 단일 상속만 지원함. 하나의 클래스는 한 번에 하나의 부모 클래스만 상속 받을 수 있어
    상속 구조가 간단하고 명확함.
2. super 키워드
   - 클래스의 생성자 및 setter에서 학습한 title에서 학습한 this와 유사한 개념으로
   부모 클래스의 field에 접근하거나 부모 클래스의 생성자를 호출할 때 사용함(두 가지 사용법 있음)
3. method override
    - 자식 클래스에서 부모 클래스의 기본 동작의 `재정의`할 수 있음. 이를 통해 자식 클래스는 부모
   클래스의 기본 동작을 자신만의 방식으로 변경 가능
    - 예시
      - Animal 클래스의 걷기를 Dog가 상속 받고, 네 발로 걷기로 _재정의_, Human 클래스가 걷기를
      상속 받고 두 발로 걷기로 _재정의_
4. final 키워드 - 클래스에 final이 붙으면 상속 불가
    - method에 final이 붙으면 메서드 오버라이딩 불가능

## 장점
1. 코드 재사용성 -> 동일한 코드를 반복적으로 작성할 필요 X
2. 유지보수의 용이성
    - 부모 클래스의 변경 사항이 자식 클래스에 자동으로 반영되기 때문에 위계 파악 후 수정하면 됨.
3. 객체 각 관계 표현 - IS-A 관계를 명확히 나타냄
    -IS-A
   '개'는 '동물'의 일종이다. 와 같은 예시로, IS-A는 is a kink of의 축약어
    - 그래서 우리가 미리 만들어준 Animal / Tiger / Human의 클래스를 예로 들었ㅇ르 때
    - Human / Tiger / Animal 클래스의 자식(서브) 클래스다.

 ## 상속을 지시하는 키워드 extends
- 재정의된 methods : 부모 메서드의 결과값과 다르게 작성한다면 전부 재정의에 해당함. 
```java
@Override   // 얘가 붙어있으면 해당 메서드는 상속 받은 것이라는 의미
public String getAnimaLName() { // 부모 클래스의 getter
        return super.getAnimaLName() + "님";
    }
```

## super 키워드
- super();             -> 얘는 부모 생성자를 호출한다는 의미
- super.메서드명();    -> 얘는 부모 클래스의 메서드를 호출한다는 의미

    지금 작성하는 부분의 경우 왜 오류가 발생하는지
    어떻게 검증하는지 어려움을 겪을 수 있다.

- 부모-자식의 상속관계가 성립되어 있을 때,
 부모 클래스에서 기본 생성자 없이 매개변수 생성자만 있다면
 자식 클래스에서 완벽한 기본 생성자를 만드는 것이 불가능하다.

-  자식 클래스의 객체 생성 시 필수적으로 '부모 클래스의 생성자를 호출'하기 때문이다.
   그치만, 자식 고유의 field를 정의할 때, 부모 클래스 생성자를 그대로 받으면서
   자식의 field가 들어간 생성자를 만드는 것은 가능!

어떤 객체를 생성한다고 가정할 때,
-   A a = new B();
   같은 형태의 객체 생성 방식이 튀어나오게 되는데(추후 수업 예정)
   이상의 방식은 정보처리기사에서 단골 문제이다.

```java
public class Product extends Item{
    // 자동 완성이 아닌 고유 메서드 하나 임의 정의
    public void showInfo(){
        System.out.println("이름 -> " + this.getName());   // 부모거라서 getter로 조회
        // this를 쓰는 이유는 메서드 이용한다고 명시해주기 위해서
        // 이 코드에서는 getName()라고 작성해도 차이가 없지만
        // 나중에 정적 메서드로 착각하는 오해가 생길 수 있기 때문에 this를 사용한다.
        System.out.println("카테고리 -> " + this.getCategory());
        System.out.println("가격 -> " + price);       // 자식거라서 field로 조회
        System.out.println("재고 -> " + stock);      // 두줄씩 코드라인의 차이가 생기는 이유에 대해 명확히 알아야 한다.
    }
}
```
